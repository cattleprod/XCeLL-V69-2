From b8570b9080244a505ccc3acd45614259ae429fa9 Mon Sep 17 00:00:00 2001
Message-Id: <b8570b9080244a505ccc3acd45614259ae429fa9.1315184977.git.hot2009wheels@hotmail.com>
In-Reply-To: <a4656eef4910f3ef802417e6bd17e3983b2fd5db.1315184977.git.hot2009wheels@hotmail.com>
References: <a4656eef4910f3ef802417e6bd17e3983b2fd5db.1315184977.git.hot2009wheels@hotmail.com>
From: LorD ClockaN <davor@losinj.com>
Date: Tue, 21 Jun 2011 19:08:17 +0200
Subject: [PATCH 02/14] ashmem: fix deadlock when system is low on memory

    When system is low on memory, allocating memory while holding the
    ashmem_mutex may try to directly reclaim memory. Then ashmem_shrink()
    is called in same thread. It will deadlock at acquiring ashmem_mutex.
    This change lets ashmem_shrink() return failure if ashmem_mutex is not
    available. Memory will be reclaimed from others.

    Change-Id: I3b6024d5477d37245f4ebde6d7069fb77af789ee
    Signed-off-by: Yuanyuan Zhong <yuanyuan.zhong@gmail.com>
---
 mm/ashmem.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/mm/ashmem.c b/mm/ashmem.c
index 5384e8d..d5b8a76 100644
--- a/mm/ashmem.c
+++ b/mm/ashmem.c
@@ -368,7 +368,8 @@ static int ashmem_shrink(struct shrinker *s, int nr_to_scan, gfp_t gfp_mask)
 	if (!nr_to_scan)
 		return lru_count;
 
-	mutex_lock(&ashmem_mutex);
+	if (!mutex_trylock(&ashmem_mutex))
+		return -1;
 	list_for_each_entry_safe(range, next, &ashmem_lru_list, lru) {
 		struct inode *inode = range->asma->file->f_dentry->d_inode;
 		loff_t start = range->pgstart * PAGE_SIZE;
-- 
1.7.4.1

